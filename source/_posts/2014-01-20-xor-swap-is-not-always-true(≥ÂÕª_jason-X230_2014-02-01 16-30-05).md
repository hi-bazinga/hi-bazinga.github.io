title: 异或交换的陷阱
date: 2014-01-20 17:04:35
categories: 学习笔记
tags:
	- trick
---

今天在写快排算法时需要交换数组中两个位置的值，准备写一个swap方法，刚准备敲下`int tmp = ...`，突然想到可以用一种更cool的方法来做，很快敲下三行代码：

	list[a] = list[a] ^ list[b];
	list[b] = list[a] ^ list[b];
	list[a] = list[a] ^ list[b];

信心满满地Run，结果输出结果大跌眼镜：

	...
	0
	0
	9975
	9977
	0
	9982
	0
	...

list的很多元素值变为0，纠结了半天，一开始以为是quicksort方法里出了错，后来单独测试swap时终于发现了问题的关键所在！这里有个很隐蔽的陷阱，注意，这里交换的数组中的元素，而不是简单的两个变量。当`list[a]`和`list[b]`中的a和b相等时，问题就来了：

<!--more-->

	// 若a = b
	list[a] = list[a] ^ list[b];	//list[a] 和 list[b] 值相等，异或后为0，即 list[a] = 0
	list[b] = list[a] ^ list[b];	//因为a = b，此时等号右边的list[b] 就是 list[a]，它的值已经被赋值为0了！
	list[a] = list[a] ^ list[b];	//三条语句执行完，list[a]被赋值为0，这就是最终结果

如果不是交换数组元素，而是普通的int变量，过程应该是这样的：

	// 若a = b
	a = a ^ b    //a和b相等，异或后为0，即a = 0
	b = a ^ b    //此时b还是原来那个b，而a = 0，b = 0 ^ b，此时b不变，保持原值
	a = a ^ b    //a = 0 ^ b，a被赋值为b，此时a和b的值与原来相同，因为a = b，也相当于a和b交换

既然交换数组元素在下标相等的情况下不能用异或，那加减行不行呢？答案同样是否定的，原理同异或。当然，如果一定要用这种不引进临时变量的交换方式，加个`if (a != b)`的判断就可以了。
